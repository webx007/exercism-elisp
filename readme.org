#+TITLE: Exercism for Elisp
:PROPERTIES:
#+STARTUP: nologdone
#+PROPERTY: header-args:shell :tangle exercism.sh
#+TODO: TODO(t) | DONE(d)
:END:

Dabbling with Emacs Lisp (elisp).

Solutions for the [[https://exercism.org/tracks/emacs-lisp][Exercism Emacs Lisp Track]]

* Exercism
** Installing
#+begin_src shell :var DIR="local/bin"
echo "$HOME/$DIR"
which exercism
if [ $? -ne 0]
then
    TAR=exercism-3.1.0-linux-x86_64.tar.gz
    wget "https://github.com/exercism/cli/releases/download/v3.1.0/$TAR"
    mkdir tmp
    [ $? -eq 0 ] && echo "downloaded $TAR" && tar xzf "$TAR" -C tmp
    [ $? -eq 0 ] && echo "extracted"
    [ -a "tmp/exercism" ] && echo "excercism installed"
    mv -f tmp/exercism "$HOME/$DIR"
    rm -Rf tmp "$TAR"
fi
#+end_src

** Configure

To configure exercism, the following input is required:
- *token* - obtained from exercism web page under profile settings. Save this string to file, and specify file location in input var for the script below.
- *workspace folder* - folder exercism will user for it tracks/exercises

Run below to create workspace with token.

#+begin_src shell :var TOKEN_FILE="my_token" :results output
TOKEN=$(cat $TOKEN_FILE)
mkdir exercism
exercism configure --token=$TOKEN -w "$(pwd)/exercism" 2>&1
echo "$(pwd)/exercism"
#+end_src

Get the workspace path
#+NAME: exercism-workspace
#+begin_src shell :cache yes
exercism workspace
#+end_src

#+RESULTS[763e1c1a27d23699f2b4113bdaf7f63a89f37870]: exercism-workspace
: ~/code/elisp/exercism

#+NAME: exercism-track
: emacs-lisp

* Exercises
** Acronym
Convert a long phrase to its acronym.
#+begin_src shell
exercism download -t emacs-lisp -e acronym
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/acronym

[[https://exercism.org/tracks/emacs-lisp/exercises/acronym][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/acronym/acronym.el
;;; acronym.el --- Acronym (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

(defun acronym (phrase)
  "Generates acronym for PHRASE"
  (let ((ac ""))
    (dolist (w (split-string phrase "[^a-z]" t))
      (when (length> w 0)
        (setq ac (concat ac (upcase (substring w 0 1))))))
    ac))

(provide 'acronym)
;;; acronym.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/acronym
emacs -batch -l ert -l acronym-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Allergies
Given a person's allergy score, determine whether or not they're allergic to a given item, and their full list of allergies.
#+begin_src shell
exercism download -t emacs-lisp -e allergies
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/allergies

[[https://exercism.org/tracks/emacs-lisp/exercises/allergies][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/allergies/allergies.el
;;; allergies.el --- Allergies Exercise (exercism)  -*- lexical-binding: t; -*-
(defun allergy--score-mask (score values)
  "Uses SCORE as a bit mask to filter VALUES (LSB first). Return resulting list"
  (let ((bit-mask 1)
        (result))
    (dolist (v values (nreverse result))
      (when (> (logand score bit-mask) 0) (setq result (cons v result)))
      (setq bit-mask (lsh bit-mask 1)))))

(defun allergen-list (score)
  "Returns list of allergies as defined by allergy SCORE (integer)"
  (let ((list-of-allergies '("eggs"
                             "peanuts"
                             "shellfish"
                             "strawberries"
                             "tomatoes"
                             "chocolate"
                             "pollen"
                             "cats")))
    (allergy--score-mask score list-of-allergies)))

(defun allergic-to-p (score allergen)
  "Returns t if SCORE includes allergen ALLERGEN"
  (if (member allergen (allergen-list score))
      t
    nil))

(provide 'allergies)
;;; allergies.el ends here
#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/allergies
emacs -batch -l ert -l allergies-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** All Your Base
Convert a number, represented as a sequence of digits in one base, to any other base.
#+begin_src shell
exercism download -t emacs-lisp -e all-your-base
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/all-your-base

[[https://exercism.org/tracks/emacs-lisp/exercises/all-your-base][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/all-your-base/all-your-base.el
;;; all-your-base.el --- All Your Base (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

;;; Code:

(defun decimal-to-base (val base)
  "Converts decimal VAL to list of digits for specified BASE"
  (let ((pos 0)
        (v val)
        (nl)
        (x 0)
        (y 0))
    (while (<= (expt base pos) val)
      (setq pos (1+ pos)))
    (if (= pos 0)
        (setq nl (list 0))
      (dolist (l (number-sequence (1- pos) 0 -1))
        (setq y (expt base l)
              x (/ v y)
              v (- v (* x y)))
        (if nl (nconc nl (list x)) (setq nl (list x)))))
    nl))

(defun base-to-decimal ( values i-base )
  "Converts list of digits in VALUES for specified base in I-BASE to a decimal value. Returns the decimal value."
  (let ((pos 0)
        (val 0))
    (dolist (digit (reverse values))
      (cond ((< digit 0)
             (error "negative digit"))
            ((>= digit i-base)
             (error "invalid digit for base specified"))
            (t (setq val (+ val (* digit (expt i-base pos))))
               (setq pos (1+ pos)))))
    val))

(defun rebase (list-of-digits in-base out-base)
  "Converts LIST-OF-DIGITS from IN-BASE to digits presented in OUT-BASE"
  (let* ((val 0))
    (cond ((< in-base 2)
           (error "Invalid input base"))
          ((< out-base 2)
           (error "Invalid input base"))
          ( t
            (setq val (base-to-decimal list-of-digits in-base))
            (decimal-to-base val out-base)))))

(provide 'all-your-base)
;;; all-your-base.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/all-your-base
emacs -batch -l ert -l all-your-base-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Anagram
Given a word and a list of possible anagrams, select the correct sublist.

#+begin_src shell
exercism download -t emacs-lisp -e anagram
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/anagram

[[https://exercism.org/tracks/emacs-lisp/exercises/anagram][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/anagram/anagram.el
;; -*- lexical-binding: t -*-
;;; anagram.el --- Anagram (exercism)

;;; Commentary:

;;; Code:

(defun normalize-word (word)
  "Convert a WORD to a sorted list of lowercase characters"
;  (mapcar #'byte-to-string (sort (string-to-list (downcase word)) #'<)))
(concat (sort (string-to-list (downcase word)) #'<)))

(defun anagrams-for (word words)
  "Return a list of anagrams for WORD found in WORDS"
  (let ((norm-word (normalize-word word))
        (low-word (downcase word)))
    (mapcan
     (lambda(w) (if (string= (downcase w) low-word)
                    '()
                  (when (string= (normalize-word w) norm-word)
                    (list w))))
     words)))

(provide 'anagram)
;;; anagram.el ends here

#+end_src
*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/anagram
emacs -batch -l ert -l anagram-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Armstrong Numbers
Determine if a number is an Armstrong number.
#+begin_src shell
exercism download -t emacs-lisp -e armstrong-numbers
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/armstrong-numbers

[[https://exercism.org/tracks/emacs-lisp/exercises/armstrong-numbers][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/armstrong-numbers/armstrong-numbers.el
;;; armstrong-numbers.el --- armstrong-numbers Exercise (exercism)  -*- lexical-binding: t; -*-

(defun armstrong-p (n)
  "Test if integer N is an armstrong number"
  (let* ((as-num 0)
        (s-num (int-to-string n))                 ; convert n to a string
        (l (length s-num)))                       ; get number of digits
    (dolist (digit (string-to-list s-num) as-num) ; loop over digits
      (setq as-num (+ as-num (expt                ; sum exponent of digit
                              (- digit 48)        ; converts number ascii code to int value 
                              l))))               ; to power l
    (= n as-num)))                                ; returns true is as-num == n

(provide 'armstrong-numbers)
;;; armstrong-numbers.el ends here

#+end_src

#+RESULTS:
: armstrong-numbers

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/armstrong-numbers
emacs -batch -l ert -l armstrong-numbers-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Atbash Cipher
Create an implementation of the atbash cipher, an ancient encryption system created in the Middle East.
#+begin_src shell
exercism download -t emacs-lisp -e atbash-cipher
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/atbash-cipher

[[https://exercism.org/tracks/emacs-lisp/exercises/atbash-cipher][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/atbash-cipher/atbash-cipher.el
;;; atbash-cipher.el --- Atbash-Cipher (exercism)  -*- lexical-binding: t; -*-

(defun encode (plaintext)
  "Encode PLAINTEXT to atbash-cipher encoding."
  (let* ((clean-txt (replace-regexp-in-string "[^a-z0-9]" "" (downcase plaintext)))
        (txt-len (length clean-txt))
        (encoded-txt "")
        (char)
        (chunk-cnt 0))

    (dotimes (i txt-len)
      ;; translate char to encoded char, a-z maps to z-a
      (setq char (elt clean-txt i)
            encoded-txt (concat encoded-txt (char-to-string (if (< 96 char 123) (- 219 char) char)))
            chunk-cnt (1+ chunk-cnt))

      ;; 5 char chunks seperated by a space
      (when (and (= chunk-cnt 5)
                 (< i (- txt-len 1)))
        (setq chunk-cnt 0
              encoded-txt (concat encoded-txt " "))))

    ;; return encoded text
    encoded-txt))

(provide 'atbash-cipher)
;;; atbash-cipher.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/atbash-cipher
emacs -batch -l ert -l atbash-cipher-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Bob
Bob is a lackadaisical teenager. In conversation, his responses are very limited.

#+begin_src shell
exercism download -t emacs-lisp -e bob
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/bob

[[https://exercism.org/tracks/emacs-lisp/exercises/bob][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/bob/bob.el
;; -*- lexical-binding: t -*-
;;; bob.el --- Bob exercise (exercism)

;;; Commentary:

;;; Code:
(defun yelling-question-p (input)
  "Returns t if INPUT is alpha-numeric content, all uppercase, and ending with a question mark"
  (when (and
         (string-suffix-p "?" input)
         (string= (upcase input) input)
         (not (string= (upcase input) (downcase input))))
    t))

(defun yelling-p (input)
  "Returns t if INPUT is alpha-numeric content and all uppercase"
  (when (and
         (string= (upcase input) input)
         (not (string= (upcase input) (downcase input))))
    t))

(defun question-p (input)
  "Returns t if INPUT is ending with a question mark"
  (when (string-suffix-p "?" input)
    t))

(defun silence-p (input)
  "Returns t if INPUT length is 0"
  (when (length= input 0)
    t))

(defun response-for (input)
  "Returns Bob's response to INPUT."
  (let ((input-clean (string-trim input)))
    (cond ((silence-p input-clean) "Fine. Be that way!")
          ((yelling-question-p input-clean) "Calm down, I know what I'm doing!")
          ((yelling-p input-clean) "Whoa, chill out!")
          ((question-p input-clean) "Sure.")
          (t "Whatever."))))

(provide 'bob)
;;; bob.el ends here

#+end_src
*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/bob
emacs -batch -l ert -l bob-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Crypto Square
Implement the classic method for composing secret messages called a square code.
#+begin_src shell
exercism download -t emacs-lisp -e crypto-square
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/crypto-square

[[https://exercism.org/tracks/emacs-lisp/exercises/crypto-square][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/crypto-square/crypto-square.el
;;; crypto-square.el --- Crypto Square (exercism)  -*- lexical-binding: t; -*-
(defun encipher (plaintext)
  "Returns encoded crypto square cipher of PLAINTEXT, chunked per row"
  (let* ((norm-txt (replace-regexp-in-string "[^a-z0-9]" "" (downcase plaintext)))
         (txt-len (length norm-txt))
         (cols 0)
         (rows 0)
         (char)
         (cipher ""))
    
    (if (= txt-len 0)
        cipher

      ;; caculate retangle size
      (setq cols (round (sqrt txt-len))
            rows cols)
      (when (< (* cols rows) txt-len)
        (setq cols (1+ cols)))

      ;; add space character to pad input text to form a retangle cols x rows
      (setq norm-txt (concat norm-txt (make-string (- (* cols rows) txt-len) 32 )))

      ;; encode text
      (dotimes (c cols)
        (dotimes (r rows)
          (setq char (char-to-string (elt norm-txt (+ c (* r cols)))))
          (setq cipher (concat cipher char)))
        (unless (= (- cols c) 1)
          (setq cipher (concat cipher " "))))
      
      ;; return encoded cipher
      cipher)))

(provide 'crypto-square)
;;; crypto-square.el ends here
#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/crypto-square
emacs -batch -l ert -l crypto-square-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Difference of Squares
Find the difference between the square of the sum and the sum of the squares of the first N natural numbers.

#+begin_src shell
exercism download -t emacs-lisp -e difference-of-squares
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/difference-of-squares

[[https://exercism.org/tracks/emacs-lisp/exercises/difference-of-squares][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/difference-of-squares/difference-of-squares.el
;; -*- lexical-binding: t -*-
;;; difference-of-squares.el --- Difference of Squares (exercism)

;;; Commentary:

;;; Code:
(defun square-of-sum (num)
    "The square of the sum of the first NUM natural numbers is (1 + 2 + ... + NUM)²"
      (expt (apply #'+ (number-sequence 1 num)) 2))

(defun sum-of-squares (num)
  "The sum of the squares of the first NUM natural numbers is 1² + 2² + ... + NUM²"
  (apply #'+ (mapcar (lambda (x) (expt x 2)) (number-sequence 1 num))))

(defun difference (num)
    "The difference between the square of the sum of the first NUM natural numbers and the sum of the squares of the first NUM natural numbers"
    (- (square-of-sum num) (sum-of-squares num)))


(provide 'difference-of-squares)
;;; difference-of-squares.el ends here

#+end_src
*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/difference-of-squares
emacs -batch -l ert -l difference-of-squares-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** ETL
We are going to do the `Transform` step of an Extract-Transform-Load.
#+begin_src shell
exercism download -t emacs-lisp -e etl
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/etl

[[https://exercism.org/tracks/emacs-lisp/exercises/etl][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/etl/etl.el
;;; etl.el --- etl Exercise (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

(defun transform (ht)
  (lambda(k v)
    (if (> k 0)
        (dolist (l v)
          (if (stringp l)
              (puthash (downcase l) k ht)
            (error "Non string letter values")))
      (error "Negative input key"))))

(defun etl (data)
  "convert scrabble letter scores in hastable DATA to new format, return new hastable"
  (let ((new-data (make-hash-table)))
    (maphash (transform new-data) data)
    new-data))

(provide 'etl)
;;; etl.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/etl
emacs -batch -l ert -l etl-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Gigasecond
Given a moment, determine the moment that would be after a gigasecond has passed.

#+begin_src shell
exercism download -t emacs-lisp -e gigasecond
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/gigasecond

[[https://exercism.org/tracks/emacs-lisp/exercises/gigasecond][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/gigasecond/gigasecond.el
;; -*- lexical-binding: t -*-
;;; gigasecond.el --- Gigasecond exercise (exercism)

;;; Commentary:
;; Calculate the date one gigasecond (10^9 seconds) from the
;; given date.
;;
;; NB: Pay attention to  Emacs' handling of time zones and dst
;; in the encode-time and decode-time functions.

;;; Code:

(defun from (s mm h d m y)
  "Adds 1Gs to the date specified by S MM H D M Y"
  (butlast                                        ; remove unwanted values from list
   (decode-time (encode-time
                 (+ s 1000000000)                 ; seconds + 1Gs
                 mm                               ; minutes
                 h                                ; hours
                 d                                ; days
                 m                                ; months
                 y                                ; years
                 "UTC")                           ; set encode time TZ
                "UTC")                            ; set decode time TZ
   3))                                            ; remove last 3 fields returned by decode-time

(provide 'gigasecond)
;;; gigasecond.el ends here

#+end_src


*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/gigasecond
emacs -batch -l ert -l gigasecond-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Grains
Calculate the number of grains of wheat on a chessboard given that the number on each square doubles.
#+begin_src shell
exercism download -t emacs-lisp -e grains
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/grains

[[https://exercism.org/tracks/emacs-lisp/exercises/grains][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/grains/grains.el
;;; grains.el --- Grains exercise (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

(defun square (n)
  "Calculate the number of grains on square N of chessboard"
  (expt 2 (1- n)))

(defun total ()
  "Calculate total number of grains on chessboard"
  (apply #'+ (mapcar #'square (number-sequence 1 64))))

(provide 'grains)
;;; grains.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/grains
emacs -batch -l ert -l grains-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Hamming
Calculate the Hamming difference between two DNA strands.

#+begin_src shell
exercism download -t emacs-lisp -e hamming
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/hamming

[[https://exercism.org/tracks/emacs-lisp/exercises/hamming][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/hamming/hamming.el
;; -*- lexical-binding: t -*-
;;; hamming.el --- Hamming (exercism)

;;; Commentary:

;;; Code:
(defun hamming-distance (a b)
  "Calculate number of differences between A B."
  (let ((strand-length (length a))
        (ham-length 0))
    (unless (= strand-length (length b))
      (error "Sequence length don't match A=%s B=%s" strand-length (length b)))
    (dotimes (i (length a) ham-length)
      (unless (= (elt a i) (elt b i))
        (setq ham-length (1+ ham-length))))))

(provide 'hamming)
;;; hamming.el ends here

#+end_src
*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/hamming
emacs -batch -l ert -l hamming-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Hello World
The classical introductory exercise. Just say "Hello, World!".

#+begin_src shell :var exname="hello-world"
exercism download -t emacs-lisp -e ${exname}
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/hello-world

[[https://exercism.org/tracks/emacs-lisp/exercises/hello-world][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/hello-world/hello-world.el
;;; hello-world.el --- Hello World Exercise (exercism)

;;; Commentary:

;;; Code:
(defun hello ()
  "Hello, World!")

(provide 'hello-world)
;;; hello-world.el ends here

#+end_src
*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/hello-world
emacs -batch -l ert -l hello-world-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Leap
Given a year, report if it is a leap year.

#+begin_src shell
exercism download -t emacs-lisp -e leap
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/leap

[[https://exercism.org/tracks/emacs-lisp/exercises/leap][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/leap/leap.el
;;; leap.el --- Leap exercise (exercism)

;;; Commentary:

;;; Code:
(defun leap-year-p (year)
  "Check if YEAR is a leap year."
  (if (= 0 (% year 4))
      (if (= 0 (% year 100))
          (if (= 0 (% year 400))
              t
            nil)
        t)
    nil))

(provide 'leap)
;;; leap.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/leap
emacs -batch -l ert -l leap-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** List Ops
Implement basic list operations.
#+begin_src shell
exercism download -t emacs-lisp -e list-ops
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/list-ops
[[https://exercism.org/tracks/emacs-lisp/exercises/list-ops][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/list-ops/list-ops.el
;;; list-ops.el --- List Ops (exercism)  -*- lexical-binding: t; -*-

(defun list-foldl (fun list accu)
  "Applies FUN to LIST items, left to right, assigning each outcome to ACCU"
  (let ((acc accu))
    (dolist (e list acc)
      (setq acc (funcall fun acc e)))))           ; ERT test uses fun acc e

(defun list-foldr (fun list accu)
    "Applies FUN to LIST items, right to left, assigning each outcome to ACCU"
  (let ((acc accu)
        (rlist (list-reverse list)))
    (dolist (e rlist acc)
      (setq acc (funcall fun e acc)))))           ; ERT test uses fun e acc

(defun list-empty-p (list)
  "Returns t if LIST is empty"
  (not list))

(defun list-sum (list)
  "returns sum of all LIST elements"
  (let ((lp list)
        (sum 0))
    (while lp
      (setq sum (+ sum (car lp)))
      (setq lp (cdr lp)))
    sum))

(defun list-length (list)
  "Calculates length of LIST"
  (let ((len 0)
        (pl list))
    (when list
      (setq len 1)
      (while (setq pl (cdr pl))
        (setq len (1+ len))))
    len))

(defun list-append (list1 list2)
  "Appends LIST2 to LIST1 and return new list"
  (let ((nl list1))
    (when list2
      (if nl
          (setcdr (last nl) list2)
      (setq nl list2)))
    nl))

(defun list-reverse (list)
  "Returns new list with all elements in LIST reversed"
  (let ((nl)
        (lp list))
    (when lp
      (setq nl (list (car lp)))
      (setq lp (cdr lp)))
    (while lp
      (setq nl (cons (car lp) nl))
      (setq lp (cdr lp)))
    nl))

(defun list-concatenate (list1 list2 &rest LISTS)
  "Returns new list consisting on contactenated elements of LIST1, LIST2 and additons lists in LISTS"
  (let ((nl (list-append list1 list2)))
    (dolist (l LISTS nl)
      (setq nl (append nl l)))))

(defun list-filter (list predicate)
  "Returns new list consisting of elements in LIST for which PREDICATE returned t"
  (let ((nl)
        (lp list))
    (when list
      (while lp
        (when (funcall predicate (car lp))
          (if nl
              (setcdr (last nl) (list (car lp)))
            (setq nl (list (car lp)))))
        (setq lp (cdr lp))))
    nl))

(defun list-map (list fun)
  "Applies FUN to each element in LIST, and returns new list containing FUN return value"
  (let ((nl))
    (dolist (e list nl)
      (if nl
          (setcdr (last nl) (cons (funcall fun e) nil))
        (setq nl (cons (funcall fun e) nil))))))

(provide 'list-ops)
;;; list-ops.el ends here
#+end_src

#+RESULTS:
: list-ops

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/list-ops
emacs -batch -l ert -l list-ops-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Luhn
Given a number determine whether or not it is valid per the Luhn formula.
#+begin_src shell
exercism download -t emacs-lisp -e luhn
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/luhn

[[https://exercism.org/tracks/emacs-lisp/exercises/luhn][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/luhn/luhn.el
;;; luhn.el --- Luhn exercise (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

(defun string-invalid-p (string)
  "Returns true if invalid input format, false if input STRING consist of digits only, min len 2"
  (if (string-match "^[0-9][0-9]+$" string)
      nil
    t))

(defun luhn-p (str)
  "Return t if number in STR has valid Luhn checksum"
  (let ((even nil)                                ; first pos is not even
        (luhn 0)
        (n 0)
        (prep-str (string-replace " " "" str)))   ; remove any spaces
    
    (if (string-invalid-p prep-str)               ; check if string is invalid
        (if (length< prep-str 2)                  ; if empty or single digit
            nil                                   ; return false
          (error "Invalid number format"))        ; else throw error

      ;; calculate luhn      
      (dolist (d (reverse (string-to-list prep-str)))
        (setq n (- d 48))
        (if even              
            (setq luhn (+ luhn
                          (elt '(0 2 4 6 8 1 3 5 7 9) n)))
          (setq luhn (+ luhn
                        n)))
        (setq even(not even)))                    ; toggle odd/even flag

      ;; check if luhn valid
      (if (= 0 (% luhn 10))                       ; is divisble by 10?
          t                                       ; yes - valid luhn
        nil))))                                   ; no - invalid luhn

(provide 'luhn)
;;; luhn.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/luhn
emacs -batch -l ert -l luhn-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Nucleotide Count
Given a DNA string, compute how many times each nucleotide occurs in the string.
#+begin_src shell
exercism download -t emacs-lisp -e nucleotide-count
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/nucleotide-count

[[https://exercism.org/tracks/emacs-lisp/exercises/nucleotide-count][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/nucleotide-count/nucleotide-count.el
;;; nucleotide-count.el --- nucleotide-count Exercise (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

(defun nucleotide-count (sequence)
  "Count nucleotides present in DNA SEQUENCE"
  (let ((dna-count (list (cons ?A 0)
                         (cons ?C 0)
                         (cons ?G 0)
                         (cons ?T 0)))
        (a-nucleotide)
        (n 0))
    (dolist (nucleotide (string-to-list sequence) dna-count)
      (if (not (setq a-nucleotide (assoc nucleotide dna-count)))
          (error "Invalid nucleotide")
        (setcdr a-nucleotide (1+ (cdr a-nucleotide)))))
    dna-count))

(provide 'nucleotide-count)
;;; nucleotide-count.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/nucleotide-count
emacs -batch -l ert -l nucleotide-count-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Pangram
Determine if a sentence is a pangram.
#+begin_src shell
exercism download -t emacs-lisp -e pangram
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/pangram

[[https://exercism.org/tracks/emacs-lisp/exercises/pangram][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/pangram/pangram.el
;;; pangram.el --- Pangram (exercism)  -*- lexical-binding: t; -*-

(defun is-pangram (phrase)
  "Returns t if the string in PHRASE is a pangram"
  (let* ((clean-phrase (replace-regexp-in-string "[^a-z]" "" (downcase phrase))))
    (length= (delete-dups (string-to-list clean-phrase)) 26)))

(provide 'pangram)
;;; pangram.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/pangram
emacs -batch -l ert -l pangram-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Perfect Numbers
Determine if a number is perfect, abundant, or deficient based on Nicomachus' (60-120 CE) classification scheme for positive integers.
#+begin_src shell
exercism download -t emacs-lisp -e perfect-numbers
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/perfect-numbers

[[https://exercism.org/tracks/emacs-lisp/exercises/perfect-numbers][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/perfect-numbers/perfect-numbers.el
;;; perfect-numbers.el --- perfect-numbers Exercise (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

(defun classify (number)
  "Returns Nicomachus classification for NUMBER, where NUMBER is a positive integer."
  (let ((limit (/ number 2))                      ; loop limit, set to largest possible factor
        (sum (if (= number 1) 0 1))               ; init sum, handles special case of number = 1
        (i 2))                                    ; set first factor to test

    ;; test if number is positive integer
    (if (or (< number 1)                          
             (not (integerp number)))

        ;; if not, raise error
        (error "Classification is only possible for natural numbers")

      ;; number is positive integer, proceed with sum
      (while (< i limit)
        (setq limit (/ number i))                 ; adjust limit
        
        (when (= (% number i) 0)                  ; test if i is factor of number
               (setq sum (+ sum                   ; factor found, update sum
                            i
                            limit)))
        (setq i (1+ i)))                          ; increment counter
      
      ;; classify results
      (cond ((< number sum) 'abundant)
            ((> number sum) 'deficient)
            ( t 'perfect)))))

(provide 'perfect-numbers)
;;; perfect-numbers.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/perfect-numbers
emacs -batch -l ert -l perfect-numbers-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Phone Number
Clean up user-entered phone numbers so that they can be sent SMS messages.
#+begin_src shell
exercism download -t emacs-lisp -e phone-number
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/phone-number

[[https://exercism.org/tracks/emacs-lisp/exercises/phone-number][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/phone-number/phone-number.el
;;; phone-number.el --- phone-number Exercise (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

(defun numbers (num)
  "Formats NANP telephone number in NUM as a 10 digit number. Invalid input returns '0000000000'"
  (let* ((clean-num (replace-regexp-in-string "[^0-9]" "" num))
         (len-num (length clean-num)))
    
    (cond ((and (= len-num 11)
                (string-prefix-p "1" clean-num))
           (substring clean-num 1 len-num))
          ((= len-num 10) clean-num)
          (t "0000000000"))))

(defun area-code (num)
  "Returns first 3 digits of NANP phone number in NUM."
  (substring (numbers num) 0 3)
)

(defun pprint (num)
  "Pretty prints NANP telephone number in NUM, format is (XXX) XXX-XXXX"
  (let* ((nanp (numbers num))
         (area-code (substring nanp 0 3))
         (exchange-code (substring nanp 3 6))
         (subscriber-num (substring nanp 6 10)))
    (format "(%s) %s-%s" area-code exchange-code subscriber-num))
)

(provide 'phone-number)
;;; phone-number.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/phone-number
emacs -batch -l ert -l phone-number-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Raindrops
Convert a number to a string, the content of which depends on the number's factors.
#+begin_src shell
exercism download -t emacs-lisp -e raindrops
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/raindrops

[[https://exercism.org/tracks/emacs-lisp/exercises/raindrops][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/raindrops/raindrops.el
;;; raindrops.el --- Raindrops (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

(defun convert (n)
  "Convert integer N to its raindrops string."
  (let ((f3 (% n 3))
        (f5 (% n 5))
        (f7 (% n 7)))

    (if (and (> f3 0)
             (> f5 0)
             (> f7 0))
        (format "%s" n)                           ; no factors, return n as string

      ;; factor found convert to raindrops
      (format "%s%s%s"
            (if (zerop f3) "Pling" "")
            (if (zerop f5) "Plang" "")
            (if (zerop f7) "Plong" "")))))

(provide 'raindrops)
;;; raindrops.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/raindrops
emacs -batch -l ert -l raindrops-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** RNA Transcription
Given a DNA strand, return its RNA Complement Transcription.

#+begin_src shell
exercism download -t emacs-lisp -e rna-transcription
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/rna-transcription

[[https://exercism.org/tracks/emacs-lisp/exercises/rna-transcription][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/rna-transcription/rna-transcription.el
;; -*- lexical-binding: t -*-
;;; rna-transcription.el -- RNA Transcription (exercism)

;;; Commentary:

;;; Code:
(defun to-rna (g)
  "Translate DNA sequence defined in G to rna sequence."
  (let ((dna-rna-compliment (list (cons ?G "C")
                                  (cons ?C "G")
                                  (cons ?T "A")
                                  (cons ?A "U"))))
    (mapconcat (lambda (nucleotide) (alist-get nucleotide dna-rna-compliment 'error)) g "")))

(provide 'rna-transcription)
;;; rna-transcription.el ends here

#+end_src

Alternate version
#+begin_src elisp :tangle no
;; -*- lexical-binding: t -*-
;;; rna-transcription.el -- RNA Transcription (exercism)

;;; Commentary:

;;; Code:
(defun to-rna (g)
  "Translate DNA sequence defined in G to rna sequence."
  (let ((dna-rna-compliment (list (cons ?G "C")
                                  (cons ?C "G")
                                  (cons ?T "A")
                                  (cons ?A "U")))
        (rna "")
        (nucleotide))
    (dotimes (i (length g) rna)
      (if (setq nucleotide (cdr (assoc (elt g i) dna-rna-compliment)))
          (setq rna (concat rna nucleotide))
        (error "Invalid DNA nucleotide %s at %s" (char-to-string (elt g i)) i)))))

(provide 'rna-transcription)
#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/rna-transcription
emacs -batch -l ert -l rna-transcription-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Robot Name
Manage robot factory settings.
#+begin_src shell
exercism download -t emacs-lisp -e robot-name
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/robot-name

[[https://exercism.org/tracks/emacs-lisp/exercises/robot-name][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/robot-name/robot-name.el
;;; robot-name.el --- Robot Name (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:
;;
;; Build a robot with a name like AA000, that can be reset
;; to a new name. Instructions are in README.md
;;

(defun build-robot ()
  "Build a new robot with a random name."
  (cons (concat (char-to-string (+ (random 26) 65))
                       (char-to-string (+ (random 26) 65))
                       (char-to-string (+ (random 9) 48))
                       (char-to-string (+ (random 9) 48))
                       (char-to-string (+ (random 9) 48))) nil))
(setf )
(defun robot-name (robot)
  "Get the ROBOT's name."
  (car robot))

(defun reset-robot (robot)
  "Reset the name of ROBOT.  Factory reset!"
  (setcar robot (build-robot)))

(provide 'robot-name)
;;; robot-name.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/robot-name
emacs -batch -l ert -l robot-name-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Roman Numerals
Write a function to convert from normal numbers to Roman Numerals.

#+begin_src shell
exercism download -t emacs-lisp -e roman-numerals
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/roman-numerals

[[https://exercism.org/tracks/emacs-lisp/exercises/roman-numerals][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/roman-numerals/roman-numerals.el
;;; roman-numerals.el --- roman-numerals exercise (exercism)

;;; Commentary:

;;; Code:
(defun to-roman (num)
  "Convert number to roman numeral"
  (if (< 0 num 10000)
      (let* ((th (/ num 1000))
             (hd (/ (- num (* th 1000)) 100))
             (tn (/ (- num (* th 1000) (* hd 100)) 10))
             (on (- num (* th 1000) (* hd 100) (* tn 10))))
                                        ;(list th hd tn on)
        (concat
         (make-string th ?M)
         (nth hd '("" "C" "CC" "CCC" "CD" "D" "DC" "DCC" "DCCC" "CM"))
         (nth tn '("" "X" "XX" "XXX" "XL" "L" "LX" "LXX" "LXXX" "XC"))
         (nth on '("" "I" "II" "III" "IV" "V" "VI" "VII" "VIII" "IX"))))
    nil))

(provide 'roman-numerals)
;; end code

#+end_src
*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/roman-numerals
emacs -batch -l ert -l roman-numerals-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Run-Length Encoding
Implement run-length encoding and decoding.
#+begin_src shell
exercism download -t emacs-lisp -e run-length-encoding
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/run-length-encoding
[[https://exercism.org/tracks/emacs-lisp/exercises/run-length-encoding][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/run-length-encoding/run-length-encoding.el
;;; run-length-encoding.el --- run-length-encoding Exercise (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

(defun run-length-encode (s)
  "RLE encode S, returns encoded string"
  (let ((s-rle "")                                ; RLE string
        (cnt 0)                                   ; character count
        (c-active 0)                              ; last char read
        (make-s-rle (lambda (s cnt c)             ; append read RLE character to RLE string
                      (concat s
                              (format "%s%s"
                                      (if (> cnt 1) cnt "")
                                      (char-to-string c))))))

    ;; loop through string, encoding each char sequence
    (dolist (c (string-to-list s))
      (if (= c c-active)
          (setq cnt (1+ cnt))
        (when (> cnt 0)
          (setq s-rle (funcall make-s-rle s-rle cnt c-active)))
        (setq cnt 1
              c-active c)))

    ;; encode last active char
    (when (> cnt 0)
      (setq s-rle (funcall make-s-rle s-rle cnt c-active)))
    s-rle))                                       ; return encoded string

(defun run-length-decode (s)
  "decode RLE encode string S, returns the decoded string"
  (let ((s-rld "")
        (cnt 0)                                   ; pos count since last char
        (rle-count 0))                            ; rle count
    (dolist (c (string-to-list s))
      (setq cnt (1+ cnt))
      (cond ((< 48 c 58 )                         ; if digit 1 to 9
             (setq rle-count                      ; update rle count
                   (+ (* rle-count (- cnt 1) 10) (- c 48))))
            (t (when (= cnt 1)                    ; if not digit, 1 char only
                 (setq rle-count 1))              ; rle-count is 1
               (setq s-rld (concat s-rld (make-string rle-count c))
                     cnt 0
                     rle-count 0))))
      s-rld))

(provide 'run-length-encoding)
;;; run-length-encoding.el ends here

#+end_src
*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/run-length-encoding
emacs -batch -l ert -l run-length-encoding-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Sublist
Write a function to determine if a list is a sublist of another list.

#+begin_src shell
exercism download -t emacs-lisp -e sublist
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/sublist

[[https://exercism.org/tracks/emacs-lisp/exercises/sublist][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/sublist/sublist.el
;; -*- lexical-binding: t -*-
;;; sublist.el --- Sublist (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:

;;; Code:

(defun list-classify (list1 list2)
  "Compares two lists: LIST1 and LIST2, to determine if they equal/subset/superset or unequal, returns keyword symbols"
  (if (equal list1 list2)
      :equal
    (if (cl-search list1 list2)
        :sublist
      (if (cl-search list2 list1)
          :superlist
        :unequal))))

(provide 'sublist)
;;; sublist.el ends here
#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/sublist
emacs -batch -l ert -l sublist-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Trinary
Convert a trinary number, represented as a string (e.g. '102012'), to its decimal equivalent using first principles.
#+begin_src shell
exercism download -t emacs-lisp -e trinary
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/trinary

[[https://exercism.org/tracks/emacs-lisp/exercises/trinary][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/trinary/trinary.el
;;; trinary.el --- Trinary (exercism)  -*- lexical-binding: t; -*-

;;; Commentary:
(defun trinary-to-decimal (string)
  "Converts STRING containing trinary number, to decimal value, returns int. Invalid input returns 0"
  (let ((digit)                                   ; digit read from string
        (val 0)                                   ; decimal value 
        (p 0))                                    ; expt power
    
    (if (string-match-p "^[0-2]+$" string)        ; if input valid trinary number
        (dolist (c (reverse (string-to-list string)) val)
          (setq digit (- c 48)                    ; convert char to decimal digit
                val (+ val (* digit (expt 3 p)))  ; convert tri digit to decimal value
                p (1+ p)))                        ; inc power for next digit pos
      val)))                                      ; return 0 for invalid input

(provide 'trinary)
;;; trinary.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/trinary
emacs -batch -l ert -l trinary-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Two Fer
Create a sentence of the form One for X, one for me..

#+begin_src shell
exercism download -t emacs-lisp -e two-fer
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/two-fer

[[https://exercism.org/tracks/emacs-lisp/exercises/two-fer][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/two-fer/two-fer.el
;;; two-fer.el --- Two-fer Exercise (exercism)

;;; Commentary:

;;; Code:
(defun two-fer (&optional name)
  (format "One for %s, one for me."
          (if name
              name
            "you")))

(provide 'two-fer)
;;; two-fer.el ends here

#+end_src

*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/two-fer
emacs -batch -l ert -l two-fer-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src

** Word Count
Given a phrase, count the occurrences of each word in that phrase.

#+begin_src shell
exercism download -t emacs-lisp -e word-count
#+end_src

#+RESULTS:
: ~/code/elisp/exercism/emacs-lisp/word-count

[[https://exercism.org/tracks/emacs-lisp/exercises/word-count][Overview]]

*** Code
#+begin_src elisp :tangle exercism/emacs-lisp/word-count/word-count.el
;; -*- lexical-binding: t -*-
;;; word-count.el --- word-count Exercise (exercism)

;;; Commentary:

;;; Code:
(defun word-count (text)
  "Counts occurrences of each word in TEXT."
  (let ((words))
    (setq words (sort (mapcar
                       (lambda (w) (downcase (string-trim w "[^a-z0-9]**" "[^a-z0-9]*")))
                       (split-string text))
                      #'string<))
    (let ((wc)
          (result))
      (dolist (w words result)                    ; iterate through list of words detected
        (when (length> w 0)                       ; ignore empty strings
          (if (setq wc (assoc-string w result))   ; if word in alist
              (setcdr wc (1+ (cdr wc)))           ; update count
            (push (cons w 1) result)))))))        ; else add entry with value of 1

(provide 'word-count)
;;; word-count.el ends here

#+end_src
*** Tests
#+begin_src shell :exports both :results output drawer :var workspace=exercism-workspace track=exercism-track
cd ${workspace}/${track}/word-count
emacs -batch -l ert -l word-count-test.el -f ert-run-tests-batch-and-exit 2>&1
#+end_src
